{"version":3,"sources":["clojulator/calculator/parser.cljc"],"mappings":"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","names":["var_args","G__39621","clojulator.calculator.parser/parser-error","js/Error","tokens","temp__5821__auto__","token","cljs.core/first","clojulator.calculator.token/lexeme","clojulator.calculator.token/pos","clojulator.calculator.parser/match","matcher","cljs.core/seq","G__39624","clojulator.calculator.token/token-type","clojulator.calculator.parser/group","expr","G__39625","clojulator.calculator.parser/expression","cljs.core/rest","remaining-tokens","clojulator.calculator.parser.parser_error","clojulator.calculator.parser/env","clojulator.calculator.parser/number","clojulator.calculator.token/literal","clojulator.calculator.parser/primary","clojulator.calculator.parser/unary","minus","p","G__39640","clojulator.calculator.parser/binary-expression","rule","matchers","left","remaining","operator","right","G__39647","clojulator.calculator.parser/exponent","clojulator.calculator.parser/factor","clojulator.calculator.parser/term","clojulator.calculator.parser/ast","tree","cljs.core/not","clojulator.calculator.parser/parse"],"sourcesContent":["(ns clojulator.calculator.parser\n  (:require [clojulator.calculator.token :as tok]))\n\n(declare expression)\n\n(defn- parser-error\n  ([] (throw #?(:clj (Exception. \"Unexpected end of input\")\n                :cljs (js/Error. \"Unexpected end of input\"))))\n  ([tokens]\n   (if-let [token (first tokens)]\n     (throw #?(:clj (Exception. (str \"Unexpected token '\" (tok/lexeme token) \"' at position \" (tok/pos token)))\n               :cljs (js/Error. (str \"Unexpected token '\" (tok/lexeme token) \"' at position \" (tok/pos token)))))\n     (throw #?(:clj (Exception. \"Unexpected end of input\")\n               :cljs (js/Error. \"Unexpected end of input\"))))))\n\n(defn- match\n  \"Returns the type of the first token in the token seqence if it matches\n  the matcher, otherwise nil.\"\n  [tokens matcher]\n  (when (seq tokens)\n    (-> tokens first tok/token-type matcher)))\n\n(defn- group\n  \"Group rule: ( <expression> )\n  Adds a group node to the AST if the next token matches :OpenParen and the\n  inner expression is enclosed in a :CloseParen. Otherwise, throws a syntax\n  error.\"\n  [tokens]\n  (when (match tokens #{:OpenParen})\n    (let [expr (expression (rest tokens))\n          remaining-tokens (:remaining expr)]\n      (if (match remaining-tokens #{:CloseParen})\n        {:node [:Group (:node expr)] :remaining (rest remaining-tokens)}\n        (parser-error (:remaining expr))))))\n\n(defn- env\n  \"Environment variable rule: p1 | p2 | p3\n  Adds an environment variable node to the AST if the next token matches\n  :Repl/*1, :Repl/*2, or :Repl/*3.\"\n  [tokens]\n  (if (match tokens #{:Repl/*1 :Repl/*2 :Repl/*3})\n    {:node [:Env (tok/lexeme (first tokens))] :remaining (rest tokens)}\n    (parser-error tokens)))\n\n(defn- number\n  \"Number rule: <number>\n  Adds a number literal to the AST if the next token matches :Number\"\n  [tokens]\n  (if (match tokens #{:Number})\n    {:node [:Number (tok/literal (first tokens))] :remaining (rest tokens)}\n    (parser-error tokens)))\n\n(defn- primary\n  \"Primary rule: <group> | <env> | <number>\n  Matches either a number literal, a group node, or an environment variable.\"\n  [tokens]\n  (cond\n    (match tokens #{:OpenParen}) (group tokens)\n    (match tokens #{:Repl/*1 :Repl/*2 :Repl/*3}) (env tokens)\n    :else (number tokens)))\n\n(defn- unary\n  \"Unary rule: - <unary> | <primary>\n  Adds a unary node to the AST if the next token matches :Minus. \n  Otherwise, matches a primary node.\"\n  [tokens]\n  (if-let [minus (match tokens #{:Minus})]\n    (let [p (unary (rest tokens))]\n      {:node [minus (:node p)] :remaining (:remaining p)})\n    (primary tokens)))\n\n(defn- binary-expression\n  \"Helper function for term, factor, and exponent rules.\"\n  [tokens rule matchers]\n  (let [left (rule tokens)]\n    (loop [expr (:node left)\n           remaining (:remaining left)]\n      (if-let [operator (match remaining matchers)]\n        (let [right (rule (rest remaining))]\n          (recur\n           [operator expr (:node right)]\n           (:remaining right)))\n        {:node expr :remaining remaining}))))\n\n(defn- exponent\n  \"Exponent rule: <unary> ( ^ <unary> )*\n Adds an exponent node to the AST if the next token matches :Caret.\"\n  [tokens]\n  (binary-expression tokens unary #{:Caret}))\n\n(defn- factor\n  \"Factor rule: <exponent> ( [* / %] <exponent> )*\n  Adds a factor node to the AST if the next token matches :Star or :Slash.\"\n  [tokens]\n  (binary-expression tokens exponent #{:Star :Slash :Modulo}))\n\n(defn- term\n  \"Term rule: <factor> ( [+ -] <factor> )*\n  Adds a term node to the AST if the next token matches :Plus or :Minus.\"\n  [tokens]\n  (binary-expression tokens factor #{:Plus :Minus}))\n\n(defn- expression\n  \"Expression rule: <term>\n  Always matches a term.\"\n  [tokens]\n  (term tokens))\n\n(defn- ast\n  \"Parses the tokens and returns the root node of the AST.\n  Throws a syntax error if the input is invalid.\"\n  [tokens]\n  (let [tree (expression tokens)]\n    (if-not (seq (:remaining tree))\n      (:node tree)\n      (parser-error (:remaining tree)))))\n\n(defn parse\n  [tokens]\n  (ast tokens))\n"]}